序列

    序列是一个计数器，它并不会与特定的表关联。通过创建Oracle序列和触发器实现表的主键自增。 
序列的用途一般用来填充主键和计数。

1，创建序列需要有 create sequence 或者create any sequence权限

	CREATE SEQUENCE 序列名
		[INCREMENT BY n]	--每次加n个
		[START WITH n]		--从n开始计数
		[{MAXVALUE/ MINVALUE n|NOMAXVALUE}] --最大/小值是n |不设置最大值
		[{CYCLE|NOCYCLE}]	--循环|一直累加，不循环
		[{CACHE n|NOCACHE}];	--设置缓存n个序列，如果系统宕掉了或其他情况，会导致序列不连续 | 不缓存

2，获得sequence值

   定义好序列值后，可以用currVal获得当前值,nextVal增加sequence值，并返回增加后的值：
   select Sequence名称.CurrVal from dual;

 注：
    - 第一次NEXTVAL返回的是初始值；随后的NEXTVAL会自动增加你定义的INCREMENT BY值，然后返回增加后的值。

      CURRVAL 总是返回当前SEQUENCE的值，但是在第一次NEXTVAL初始化之后才能使用CURRVAL，否则会出错。
       一次NEXTVAL会增加一次 SEQUENCE的值，所以如果你在同一个语句里面使用多个NEXTVAL，其值就是不一样的。
    
    - 如果指定CACHE值，ORACLE就可以预先在内存里面放置一些sequence，这样存取的快些。cache里面的取完后，
    oracle自动再取一组 到cache。
    使用cache或许会跳号， 比如数据库突然不正常down掉（shutdown abort),cache中的sequence就会丢失. 
    所以可以在create sequence的时候用nocache防止这种情况。

3, 使用范围

   在Sql语句中可以使用sequence的地方： 
    - 不包含子查询、snapshot、VIEW的 SELECT 语句 
    - INSERT语句的子查询中 
    - INSERT语句的values中 
    - UPDATE 的 SET中

    例如在插入语句中
	insert into 表名(id,name)values(seqtest.Nextval,'sequence 插入测试');

4，Alter Sequence 
    拥有ALTER ANY SEQUENCE 权限才能改动sequence. 可以alter除start至以外的所有sequence参数。
    如果想要改变start值，必须 drop sequence 再 re-create
  例：
	alter sequence SEQTEST maxvalue 9999999;
    
  另： SEQUENCE_CACHE_ENTRIES参数，设置能同时被cache的sequence数目。

 
5，Drop Sequence
	DROP SEQUENCE seqTest


6、一个例子


	create sequence SEQ_ID
	minvalue 1
	maxvalue 99999999
	start with 1
	increment by 1
	nocache
	order;

建解发器代码为：

	create or replace trigger tri_test_id
	   before insert on S_Depart   --S_Depart 是表名
	   for each row
	declare
	   nextid number;
	begin
	   IF :new.DepartId IS NULLor :new.DepartId=0 THEN --DepartId是列名
	     select SEQ_ID.nextval --SEQ_ID正是刚才创建的
	     into nextid
             from sys.dual;
	     :new.DepartId:=nextid;
	end if;
        end tri_test_id;

 OK，上面的代码就可以实现自动递增的功能了。

 注：:new 代表 数据改变后的新值，相对应的有 :old 原值
     := 代表 赋值
     :nextid表示引用sqlplus中定义的变量 



