一块网卡就是一道门，一个接口，它上面一般接协议栈，下面一般接介质。最关键的是，你要明确它们确实在上面和下面接的是什么。
由于网卡的上接口在OS中实现，或者使用PF技术在用户态实现，总而言之，它们是软的，这就意味着你可以任意实现它们。反之，下接口便不受机器运行软件的 控制了，你无法通过软件改变双绞线的事实，不是吗？故此，我们一般关注网卡下面接的是什么，是什么呢？姑且将它叫做endpoint吧。在开始正文之前， 我先列举几个常见的endpoint：
以太网ETHx：普通双绞线或者光纤；
TUN/TAP：用户可以用文件句柄操作的字符设备；
IFB：一次到原始网卡的重定向操作；
VETH：触发虚拟网卡对儿peer的RX；
VTI：加密引擎；
VETH虚拟网卡技术
关于这个虚拟网卡，我在《OpenVPN多处理之-netns容器与iptables CLUSTER》中有提到过，每一个VETH网卡都是一对儿以太网卡，除了xmit接口与常规的以太网卡驱动不同之外，其它的几乎就是一块标准的以太网 卡。VETH网卡既然是一对儿两个，那么我们把一块称作另一块的peer，标准上也是这么讲的。其xmit的实现就是：将数据发送到其peer，触发其 peer的RX。那么问题来了，这些数据如何发送到VETH网卡对儿之外呢？自问必有自答，自答如下：
1.如果确实需要将数据发到外部，通过将一块VETH网卡和一块普通ETHx网卡进行bridge，通过bridge逻辑将数据forward到ETHx，进而发出；
2.难道非要把数据包发往外部吗？类似loopback那样的，不就是自发自收吗？使用VETH可以很方面并且隐秘地将数据包从一个net namespace发送到同一台机器的另一个net namespace，并且不被嗅探到。
VETH虚拟网卡非常之简单，原理图如下所示：

 
图 veth1

 
VETH使用原始朴素的方式连接了不同的net namespace，符合UNIX的风格，因此你需要动用很多别的技术或者工具来完成net namespace的隔离以及数据的发送。