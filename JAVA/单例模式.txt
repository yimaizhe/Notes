创建实例之getinstance()函数

getInstance是一个函数。在java中，可以使用这种方式使用单例模式创建类的实例，所谓单例模式就是一个类有且只有一个实例，不像object ob=new object();的这种方式去实例化后去使用

写在前面：一个类，只是表达对象是怎样的，而如果类实例化之后，它就是一个对象了。也就是说，实体化之后的东西，就是一个东西了。一个客观的实体，可以进 行各种的操作和设置了。而对象的实例化方法，也是比较多的，最常用的方法是直接使用new ，而这是最普通的，如果要考虑到其它的需要，如单实例模式，层次 间调用等等。直接使用new 就不可以实现好的设计好，这时候需要使用间接使用new ，即很多人使用的GetInstance 方法。这是一个设计方式的代表，而不仅仅指代一个方法名。

1. new的 使用 ：
如Object _object = new Object() ，这时候，就必须要知道有第二个Object 的存在，而第二个Object 也常常是在当前的应用程序域中的，可以被直接调用的

2. GetInstance的 使用：
在主函数开始时调用，返回一个实例化对象，此对象是static 的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。

3.两者区别对照：
大部分类( 非抽象类/ 接口/ 屏蔽了constructor 的类) 都可以用new ，new 就是通过生产一个新的实例对象， 或者在栈上声明一个对象 ，每部分的调用用的都是一个新的对象。
getInstance 是少部分类才有的一个方法，各自的实现也不同。getInstance 在单例模式(保证一个类仅有一个实例，并提供一个访问它的全局访问点)的类中常见，用来生成唯一的实例，getInstance 往往是static 的。

(1) 对象使用之前通过getinstance 得到而不需要自己定义，用完之后不需要delete；
(2) new 一定要生成一个新对象，分配内存； getInstance () 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于 new ；
(3) new 创建后只能当次使用，而 getInstance() 可以跨栈区域使用，或者远程跨区域使用。所以 getInstance() 通常是创建 static 静态实例方法的。

例如：
class A
{
public:
A(void);
…..
}
如果在每一个需要A的类中都声明一个A类的对象，那么会导致有N个类，每个A类的定义都不一样，但是这个A类是服务类，又只能定义一次，定义多个A类会导致A类有多个不同的内存地址。
解决这个矛盾的方法：
定义一个A的全局类对象，其它类共同使用这个实例化对象，这样保证A只实例化一次，使用extern A a声明一次，在源文件中定义A a即可；
但这种方式有一个问题，就是工程之间的访问，例如pro1中有A类，pro2需要使用A类，这样就不能完全保证A类只实例化一次，可能会出现pro1和pro2各实例化一次。
2. 定义静态的实例化类(Singleton),如下：
class A
{
public:
A(void);
static A* GetInstance()
{
static A* a = NULL;
if(a == null)
{
a = new A;
};
return a;
}
……
}
这样只要包含这个头文件，
A::GetInstance()->…..
这样就保证只实例化一次。