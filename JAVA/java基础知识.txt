1，final类不能被继承；final方法不能被重写，其行为不允许子类篡改;

2，上转型对象： 子类对象转换为父类对象，被简化（失去独有的属性），可以再次转为子类，重新获得独有的属性；是子类对象的简化形态，不关心子类新增功能，只关心子类继承和重写的功能；（多态的体现――不同对象的上转型对象调用同一方法可能产生不同的行为）

3，abstract: 抽象类可以有abstract方法也可以有非abstract方法，抽象方法只允许声明，不允许实现；不能同时使用final和abstract同时修饰一个方法； 抽象类不允许用new运算符创建对象（无对应内存）；

4，继承： extends, Java不支持多继承，即一个类只能有一个父类；单继承保证了程序的健壮性和易维护，但增加了子类的负担，使用不当会引起混乱；
     接口，interface： 为了解决单继承的缺点，java使用了接口，一个类可以实现多个接口；接口类中只能进行方法的声明，不能提供实现，可以省略public和abstract； 一个类实现某个接口时，用关键字implements，必须实现该接口的所有方法，必须用public修饰；接口可以被继承；保证了程序的健壮性和易维护性，且不失灵活性；
      接口回调： 可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量中，当接口变量调用被类实现的接口中的方法是，就是通知相应的对象调用接口的方法（多态的另一种体现）；使用接口进行程序设计的核心思想是使用接口回调；
     抽象类 VS 接口类：

    都可以有抽象方法
    接口中只可以有常量，不能有变量；抽象类都可以有
    抽象类中可以有非抽象方法，接口不可以。

     子类除了需要实现父类的抽象方法，还需要从父类继承一些变量或者继承一些重要的非抽象方法，则可以考虑使用抽象类；如果不需要继承，只需要若干个类给出某些重要的抽象方法的实现细节，则可以考虑使用接口

5，匿名类：不可以声明static成员变量和static方法； 主要用途--向方法的参数传值；

6, 泛型：建立具有类型安全的集合框架，如链表、散列映射等数据结构; 优点---在使用泛型类建立数据结构时不必进行强制类型转换；

7，字符串转换为其他基本类型： parse*(),eg――parseByte（String）, parseInt（String）, parseLong（String）;
     Long类型 获取各种进制的字符串表示： toBinaryString(long i), toOctalString(long i), toHexString(long i), toString(long i, int p) 返回整数i的p进制
     String类创建的字符串对象是不可修改的，一旦创建，实体便不会发生变化； StringBuffer可以创建可修改的字符串序列；

8，线程被创建后就具备了运行条件，一旦轮到它来享用CPU资源时，即JVM将CPU使用权切换给该线程时，该线程就可以脱离创建它的主线程、独立开始自己的生命周期了； 线程创建后仅仅是占有了内存资源，在JVM管理的线程中还没有该线程，该线程必须调用start()方法（从父类继承的方法）通知JVM；当JVM将CPU的使用权切换给线程时，如果线程是Thread的子类创建的，该类中的run()方法就立刻执行； 在run（）结束前，不要让线程再次调用start（）方法；

         中断：（1）线程调度，时间片到；（2）执行了sleep（）； 时间到后重新进到线程队列排队等待CPU资源；（3）执行了wait()；不会主动进线程对列，必须由其他线程调用notify（）方法通知； （4），执行了某个操作进入阻塞状态，如读写，引起阻塞的原因消除时，线程才重新进入到线程队列；
         死亡： 正常运行的线程完成了全部工作，即执行完了run（）方法中的全部语句，结束了run（）方法；线程被提前强制性终止；

     创建线程可用Thread类或Thread的子类创建，使用子类创建线程的优点：可在子类中增加新的成员变量，使线程具有某种属性，也可在子类中新增加方法，使线程具有 某种功能。Java不支持多继承，子类不能再扩展其他类；
      通过Thread类直接创建线程对象，用实现Runnable接口的类作为参数；线程调用start（）时自动调用run（）；更灵活；
     Thread类的run()方法与Runnable接口中的run()方法的功能作用相同，都是用来定义线程对象被调用后所执行的操作，都是系统自动调用而用户程序不得引用的方法。
    注意：一个已经运行的线程在没有进入死亡状态时，不要再给线程分配实体，由于线程只能引用最后分配的实体，先前的实体就会成为“垃圾”，并且不会被垃圾收集机制收集掉；eg:
                             Thread thread = new Thread(target);
                             thread.start();
 如果线程thread占有CPU资源进入了运行状态，再执行
                             thread = new Thread(target);
先前的实体就会成为“垃圾”

9，synchronized，线程同步：若干个线程都需要使用一个synchronized修饰的方法； 多个线程访问同一个变量，为防止引起混乱，使用同步方法修改该数据，在同步方法返回之前/同步方法调用执行完毕之前，其他占有CPU资源的线程一旦调用这个同步方法就会引起阻塞；
     wait()方法可以中断线程的执行，使本线程等待，暂时让出cpu使用权，并允许其他线程使用这个同步方法；其他线程使用完这个同步方法的同时，应当用notifyAll()通知所有的 由于使用这个同步方法而处于等待的线程 结束等待；

10，线程联合： 一个线程A在占有CPU资源期间，可以让其他线程调用join()和本线程联合；一旦联合其他线程，该线程将立刻中断执行，一直等到他联合的线程执行完毕，该线程再重新排队等待资源；如果联合的其他线程已经结束，则join不会产生任何效果；

11，守护线程：线程调用void setDaemon(boolean on)设置为守护线程；默认是非守护线程，也称用户线程； 当程序中所有用户线程已经结束运行时，即使守护线程的run()方法还有需要执行的语句，也立刻结束运行；一般用于做一些不是很严格的工作，随时结束不会产生什么不良后果；

12,单例类
     Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。”
通过单例模式可以保证系统中一个类只有一个实例
有多种写法，区别在于何时初始化instance：懒汉（线程不安全、线程安全）、饿汉（在类初始化时即实例化instance）、静态内部类、枚举（不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象）、双重校验锁
http://cantellow.iteye.com/blog/838473
eg:(懒汉)
                     public class Test{
                         private static Test instance;
                         public static Test getInstance(){
                             if(instance==null){
                                 instance = new Test();
                             }
                             return instance;
                         }
                     }
     注意： .

    如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例
    .如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。

Others:
1,函数返回值：return new long[]{idle,total}； 即返回一个long数组；








